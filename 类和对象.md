# 类和对象

## 类

Java中把具有相同性质、方法的一组对象的集合作为“类”。定义方法：

```java
[修饰] class ClassName {
}
```

类名的首字母应大写。  
在类中可以定义属性、方法和构造函数。

```java
int attr1;
String attr2;
......
public static void method(){
    //ToDo
}
......
className (String name){
    //ToDo
}
```

构造函数不能定义返回值  
构造函数具体语法说明：  
1.修饰符：可省略或为public,private,protected之一  
2.构造函数名与类名相同  
3.参数语法与方法中参数的语法一致  
当没有手动添加构造函数时，系统会自动加入参数为空、方法体为空的构造函数。  
对于属性和方法而言，如果使用了`static`关键字修饰，那么该属性或方法可以被类和实例对象直接调用。若没有，则只能被实例对象调用。

## 对象

定义类后，可以生成其对象，并定义属性和方法。  
假设先前定义了Dog类，生成对象的方法：

```java
Dod d = new Dog();
```

其中`Dog d`生成了一个Dog类型的对象，`new`为创建对象的关键字，`Dog()`实际上是调用了Dog类中的参数为空的构造函数。  
真正生成对象的操作是`new Dog()`,而d只是一个**引用**（或称为“**句柄\(Handle\)**”），在内存中指向这个对象。  
因此，我们操作的实际上只是对象的应用，而非对象本身。  
生成的对象可以定义/访问其属性:

```java
d.name = "doge";
d.age = 2;
d.hearTheRing();
```

![内存模型](/assets/画板 1.png)  
上图是p对象的内存模型。



## 保存到什么地方

程序运行时，。有六个地方都可以保存数据：

\(1\) **寄存器**。这是**最快**的保存区域，因为它位于和其他所有保存方式不同的地方：**处理器内部**。寄存器的**数量十分有限**，所以寄存器是根据需要**由编译器分配**。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。

\(2\)** 堆栈**。驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种**特别快、特别有效**的数据保存方式，仅次于寄存器。创建程序时，J**ava编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”**。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中。

\(3\)** 堆**。一种常规用途的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于**编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间**。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！

\(4\)** 静态存储**。这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。

\(5\)** 常数存储**。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。

\(6\) **非RAM存储**。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。Java 1.1提供了对Lightweight persistence的支持。



## 



